package repository

import (
	"context"
	"database/sql"
	"fmt"
	"log"

	"github.com/google/uuid"

	"github.com/kasbuunk/microservice/user"
)

const tableName = "users"

// UserRepository implements the Repository interface for the User model.
type UserRepository struct {
	UserDB *sql.DB
}

func New(db *sql.DB) Repository {
	return UserRepository{
		UserDB: db,
	}
}

func (us UserRepository) Save(usr user.User) (user.User, error) {
	// if id is set, update
	if usr.ID.String() != "" {
		updatedUser, err := updateByID(us.UserDB, tableName, usr)
		if err != nil {
			return usr, fmt.Errorf("updating user")
		}
		return updatedUser, nil
	}

	// if id is not set, create

	//if savedUser.ID.String() == "" {
	//	return &user.User{}, fmt.Errorf("saving user: %w", err)
	//}
	return usr, nil
}
func (us UserRepository) User(id uuid.UUID) (user.User, error) {
	usr, err := selectByID(us.UserDB, tableName, id)
	if err != nil {
		return user.User{}, fmt.Errorf("querying user by id: %w", err)
	}
	return usr, nil
}

func selectByID(db *sql.DB, table string, id uuid.UUID) (user.User, error) {
	rows, err := db.Query(
		fmt.Sprintf(
			"SELECT * FROM `%s` WHERE id = ? LIMIT 1;",
			table,
		),
		id.String(),
	)
	if err != nil {
		return user.User{}, fmt.Errorf("querying db: %w", err)
	}

	// Candidate for generics. Replace the return 'user.User' type by a type parameter.
	var obj user.User
	err = rows.Scan(obj)
	if err != nil {
		return user.User{}, fmt.Errorf("scanning rows: %w", err)
	}

	return obj, nil
}

func updateByID(db *sql.DB, table string, obj user.User) (user.User, error) {
	result, err := db.ExecContext(context.Background(),
		fmt.Sprintf(
			"UPDATE `%s` SET `%s` WHERE id = ?;",
			table,
			updateSetValues([]string{
				"email",
			},
			),
		),
		string(obj.Email),
		obj.ID.String(),
	)
	if err != nil {
		return user.User{}, fmt.Errorf("updating db: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return user.User{}, fmt.Errorf(" rows: %w", err)
	}
	if rows != 1 {
		log.Fatalf("expected to affect 1 row, affected %d", rows)
	}

	return obj, nil
}

func updateSetValues(fields []string) string {
	setString := "( "
	for _, field := range fields {
		setString = setString + fmt.Sprintf("%s = ?", field)
	}
	setString += " )"
	return setString
}

// Repository is the storage interface through which User entities are retrieved, created and updated from storage.
type Repository interface {
	// User 'gets' the user instance from the repository by ID. Its implementation is abstracted away.
	User(uuid.UUID) (user.User, error)
	// Save returns a new user instance. This is often achieved by passing in a pointer to a model instance,
	// with in-place modification of the object, like populating the ID generated by the database.
	// While that may be a little faster, returning a new instance has the benefits of immutable objects.
	// Any old reference will need the newly saved instance. Fewer side-effects, more expected behaviour.
	//
	// Create a new user by calling user.New(params), which checks any invariants for validation. Then, call its
	// Save method, which - if no ID is set yet - will save it to the chosen storage interface and populate its ID.
	//
	// Update an existing user by first getting it with the User(ID) method, calling methods that may change its
	// internal state and then call Save(user) to persist changes to the chosen storage interface.
	Save(user.User) (user.User, error)
}
